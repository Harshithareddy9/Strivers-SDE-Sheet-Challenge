#include <bits/stdc++.h> 
/*int search(vector<int> arr, int strt, int end, int value)
{
    for (int i = strt; i <= end; i++)
        if (arr[i] == value)
            return i;
    return -1;
}
 

int getHeight(vector<int> in, vector<int> level, int start, int end, int &height, int n) {
	if (start > end)
        return 0;
 
    // Get index of current root in InOrder Traversal
    int getIndex = search(in, start, end, level[0]);
 
    if (getIndex == -1)
        return 0;
 
    // Count elements in Left Subtree
    int leftCount = getIndex - start;
 
    // Count elements in right Subtree
    int rightCount = end - getIndex;
 
    // Declare two arrays for left and
    // right subtrees
    vector<int> newLeftLevel(leftCount) ;
    vector<int> newRightLevel(rightCount);
 
    int lheight = 0, rheight = 0;
    int k = 0;
 
    // Extract values from level order traversal array
    // for current left subtree
    for (int i = 0; i < n; i++) {
        for (int j = start; j < getIndex; j++) {
            if (level[i] == in[j]) {
                newLeftLevel[k] = level[i];
                k++;
                break;
            }
        }
    }
 
    k = 0;
 
    // Extract values from level order traversal array
    // for current right subtree
    for (int i = 0; i < n; i++) {
        for (int j = getIndex + 1; j <= end; j++) {
            if (level[i] == in[j]) {
                newRightLevel[k] = level[i];
                k++;
                break;
            }
        }
    }
 
    // Recursively call to calculate height of left Subtree
    if (leftCount > 0)
        lheight = getHeight(in, newLeftLevel, start,
                            getIndex - 1, height, leftCount);
 
    // Recursively call to calculate height of right Subtree
    if (rightCount > 0)
        rheight = getHeight(in, newRightLevel,
                            getIndex + 1, end, height, rightCount);
 
    // Current height
    height = max(lheight + 1, rheight + 1);
 
    // Delete Auxiliary arrays
  //delete[] newRightLevel;
   // delete[] newLeftLevel;
 
    // return height
    return height;
}
int heightOfTheTree(vector<int>& inorder, vector<int>& levelOrder, int N){
	// Write your code here.
	int h=0;
    return getHeight(inorder, levelOrder,  0, N-1, h, N)-1;

}*/

int heightOfTheTree(vector<int>& inorder, vector<int>& levelOrder, int N){
	unordered_map<int, int> mp; // Inorder Node value -> index in inorder array
    queue<vector<int>> q; // {start, end, height}
    
    for(int i = 0; i < inorder.size(); i++){
        mp[inorder[i]] = i;
    }
    
    if(mp.find(levelOrder[0]) != mp.end()){
        // root is the last element in inorder traversal then it has no right subtree
        if(mp[levelOrder[0]] == inorder.size()-1) 
            q.push({0, (int)inorder.size()-2, 1});
        // root is the first element in inorder traversal then it has no left subtree
        else if(mp[levelOrder[0]] == 0)
            q.push({1, (int)inorder.size()-1, 1});
        else
        {
            q.push({0, mp[levelOrder[0]]-1, 1});    // left subtree
            q.push({mp[levelOrder[0]]+1, (int)inorder.size()-1, 1});    // right subtree
        }
    }
    int k = 1;
    int ans = 0;
   while(!q.empty())
   {  
    auto temp = q.front();
    q.pop();
    ans = max(ans, temp[2]);
    if(mp.find(levelOrder[k]) != mp.end()){  
        // if it is the leaf node i.e. no left subtree and no right subtree 
        if(temp[0] == temp[1]) 
            ans = max(ans, temp[2] + 1);
        // root is the last element in inorder traversal then it has no right subtree
        else if(mp[levelOrder[k]] == temp[1])
            q.push({temp[0], temp[1]-1, temp[2]+1});
        // root is the first element in inorder traversal then it has no left subtree
        else if(mp[levelOrder[k]] == temp[0])
            q.push({temp[0]+1, temp[1], temp[2]+1});
        else
        {
            q.push({temp[0], mp[levelOrder[k]]-1, temp[2]+1}); // left subtree
            q.push(
                {mp[levelOrder[k]] + 1, temp[1], temp[2] + 1}); // right subtree
        }
    }
    k++;
   }
   return ans - 1;
}
